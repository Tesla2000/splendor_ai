# -*- coding: utf-8 -*-
"""neat_splendor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FeMVs2DRYEPc4u9DSf2zhvuqgd-0Bffe
"""

import neat
from copy import deepcopy
import random
import numpy as np

resource_limit = 7
gold_limit = 5

cards_in_row = 4

player_resource_max = 14
resource_limit_for_two = 4
resource_111 = range(25)
resource_2 = range(25, 30)
reserve_card = range(30, 45)
build_card_row = range(45, 57)
build_card_reserve = range(57, 60)


class Card:
    def __init__(self, points, production, red, green, blue, brown, white, tier):
        self.points = points
        self.production = production
        self.cost = {
            Resource.RED: red,
            Resource.GREEN: green,
            Resource.BLUE: blue,
            Resource.BROWN: brown,
            Resource.WHITE: white
        }
        self.tier = tier


from enum import Enum


class Tier(Enum):
    FIRST = 0
    SECOND = 1
    THIRD = 2
    RESERVE = 3


class Resource(Enum):
    GOLD = 6
    RED = 1
    GREEN = 2
    BLUE = 3
    BROWN = 4
    WHITE = 5


class Aristocrat:
    def __init__(self, points=3, red=0, green=0, blue=0, brown=0, white=0):
        self.points = points
        self.requirements = {
            Resource.RED: red,
            Resource.GREEN: green,
            Resource.BLUE: blue,
            Resource.BROWN: brown,
            Resource.WHITE: white
        }


def generate_aristocrats():
    return [Aristocrat(red=4, green=4), Aristocrat(red=4, brown=4),
            Aristocrat(brown=4, white=4), Aristocrat(green=4, blue=4),
            Aristocrat(white=4, blue=4), Aristocrat(white=3, blue=3, green=3),
            Aristocrat(green=3, red=3, brown=3), Aristocrat(blue=3, green=3, red=3),
            Aristocrat(red=3, white=3, brown=3), Aristocrat(blue=3, white=3, brown=3)]


def generate_cards():
    with open("buildings.txt", 'r') as file:
        content = file.read()
    cards = [[], [], []]
    for line in content.split('\n'):
        try:
            tier, production, points, _, white, blue, green, red, brown = line.split('\t')
            productions = {'black': Resource.BROWN, 'blue': Resource.BLUE, 'red': Resource.RED, 'white': Resource.WHITE,
                           'green': Resource.GREEN}
            if tier == '1':
                cards[0].append(
                    Card(int(points), productions[production], int(red), int(green), int(blue), int(brown), int(white),
                         Tier.FIRST))
            elif tier == '2':
                cards[1].append(
                    Card(int(points), productions[production], int(red), int(green), int(blue), int(brown), int(white),
                         Tier.SECOND))
            else:
                cards[2].append(
                    Card(int(points), productions[production], int(red), int(green), int(blue), int(brown), int(white),
                         Tier.THIRD))
        except ValueError:
            pass
    return cards


class Board:
    def __init__(self, number_of_players=2, red=resource_limit, green=resource_limit, blue=resource_limit,
                 brown=resource_limit,
                 white=resource_limit,
                 gold=gold_limit, aristocrats=None, cards=None):
        if cards is None:
            cards = generate_cards()
        if aristocrats is None:
            aristocrats = generate_aristocrats()
        self.available_resources = {Resource.RED: red, Resource.GREEN: green, Resource.BLUE: blue,
                                    Resource.BROWN: brown,
                                    Resource.WHITE: white, Resource.GOLD: gold}
        self.aristocrats = aristocrats
        self.cards = cards
        self.visible_aristocrats = self._shove_cards(self.aristocrats)[:cards_in_row]
        for i in range(len(cards)):
            cards[i] = self._shove_cards(cards[i])
        self.visible_cards = self.cards[0][:cards_in_row] + self.cards[1][:cards_in_row] + self.cards[2][:cards_in_row]
        self.cards[0] = self.cards[0][cards_in_row:]
        self.cards[1] = self.cards[1][cards_in_row:]
        self.cards[2] = self.cards[2][cards_in_row:]

    @staticmethod
    def _shove_cards(deck):
        holder = []
        while len(deck) >= 1:
            holder.append(deck.pop(random.randint(0, len(deck) - 1)))
        return holder

    def take_card(self, tier, index):
        if len(self.cards[tier.value]) > 0:
            self.visible_cards.insert(cards_in_row * (tier.value + 1), self.cards[tier.value].pop())
        else:
            self.visible_cards.insert(cards_in_row * (tier.value + 1), None)
        return self.visible_cards.pop(index + cards_in_row * tier.value)

    def give_resource(self, amount):
        if isinstance(amount, tuple):
            if len(amount) == 2 and amount[0] == amount[1]:
                pass
            for resource in amount:
                self.available_resources[resource] -= 1
        else:
            for resource in amount:
                if self.available_resources[resource] < amount[resource]:
                    raise ValueError
                else:
                    self.available_resources[resource] -= amount[resource]

    def get_resource(self, amount):
        for resource in amount:
            self.available_resources[resource] += amount[resource]

    def reserve_card(self, tier, index):
        if index == cards_in_row:
            return self.cards[tier.value].pop()
        return self.take_card(tier, index)

    def check_aristocrats(self, player):
        for aristocrat in self.aristocrats:
            for resource in aristocrat.requirements:
                if aristocrat.requirements[resource] > player.get_production()[resource]:
                    break
            else:
                player.get_aristocrat(self.aristocrats.pop(aristocrat))


class Game:
    def __init__(self, genomes, config):
        self.players = []
        for genome_id, genome in genomes:
            net = neat.nn.FeedForwardNetwork.create(genome, config)
            self.players.append(Player(genome_id, net))
        self.board = Board()
        self.round = 0

    def end_turn(self):
        self.update_resources()
        self.players.append(self.players.pop(0))

    def get_state(self):
        state = [self.board.available_resources[Resource.RED], self.board.available_resources[Resource.GREEN],
                 self.board.available_resources[Resource.BLUE], self.board.available_resources[Resource.BROWN],
                 self.board.available_resources[Resource.WHITE], self.board.available_resources[Resource.GOLD]]
        for card in self.board.visible_cards:
            if card:
                production = 5 * [0]
                production[card.production.value - 1] = 1
                state.extend(
                    (
                        card.cost[Resource.RED], card.cost[Resource.GREEN], card.cost[Resource.BLUE],
                        card.cost[Resource.BROWN],
                        card.cost[Resource.WHITE]))
                state.extend(production)
            else:
                state.extend(
                    (
                        1000, 1000, 1000,
                        1000,
                        1000, 0, 0, 0, 0, 0))
        for aristocrat in self.board.aristocrats:
            state.extend((aristocrat.requirements.get(Resource.RED), aristocrat.requirements.get(Resource.GREEN),
                          aristocrat.requirements.get(Resource.BLUE), aristocrat.requirements.get(Resource.BROWN),
                          aristocrat.requirements.get(Resource.WHITE),))
        for player in self.players:
            prod = player.get_production()
            state.extend(
                (player.points, prod.get(Resource.RED, 0), prod.get(Resource.GREEN, 0), prod.get(Resource.BLUE, 0),
                 prod.get(Resource.BROWN, 0), prod.get(Resource.WHITE, 0), player.resources.get(Resource.RED, 0),
                 player.resources.get(Resource.GREEN, 0), player.resources.get(Resource.BLUE, 0),
                 player.resources.get(Resource.BROWN, 0), player.resources.get(Resource.WHITE, 0),
                 player.resources.get(Resource.GOLD, 0),
                 len(player.reserve)))
        return np.array(state, dtype=np.int8)

    def reset(self):
        for player in self.players:
            player.resources = {}
            player.aristocrats = []
            player.points = 0
            player.cards = []
            player.reserve = []
        self.board = Board()
        self.round += 1

    def update_resources(self):
        self.board.available_resources = {Resource.RED: resource_limit, Resource.GREEN: resource_limit,
                                          Resource.BLUE: resource_limit,
                                          Resource.BROWN: resource_limit,
                                          Resource.WHITE: resource_limit, Resource.GOLD: gold_limit}
        for player in self.players:
            for resource in player.resources:
                self.board.available_resources[resource] -= player.resources[resource]


class Player:
    def __init__(self, genome, net, points=0, cards=None, aristocrats=None, reserve=None, red=0, green=0, blue=0,
                 brown=0, white=0):
        self.id = genome
        self.net = net
        if cards is None:
            self.cards = []
        self.resources = {
            Resource.RED: red,
            Resource.GREEN: green,
            Resource.BLUE: blue,
            Resource.BROWN: brown,
            Resource.WHITE: white
        }
        self.points = points
        if aristocrats is None:
            self.aristocrats = []
        if reserve is None:
            self.reserve = []

    def get_production(self):
        counter = dict()
        for card in self.cards:
            counter[card.production] = counter.get(card.production, 0) + 1
        return counter

    def get_card(self, card):
        self.cards.append(card)
        self.points += card.points

    def get_resource(self, option):
        for resource in option:
            self.resources[resource] = self.resources.get(resource, 0) + 1

    def get_aristocrat(self, aristocrat):
        self.aristocrats.append(aristocrat)
        self.points += aristocrat.points

    def add_reserve(self, card):
        self.reserve.append(card)

    def build_reserve(self, index):
        self.cards.append(self.reserve.pop(index))

    def get_action(self, game):
        action = self.net.activate(game.get_state())
        return action

    def pay(self, cost):
        gold_needed = 0
        paid = {}
        for resource in cost:
            gold_needed += max(0, -self.resources.get(resource, 0) - self.get_production().get(resource, 0) + cost.get(
                resource, 0))
        if gold_needed > self.resources.get(Resource.GOLD, 0):
            raise ValueError("Too little gold")
        else:
            paid[Resource.GOLD] = gold_needed
            self.resources[Resource.GOLD] = self.resources.get(Resource.GOLD, 0) - gold_needed
            for resource in cost:
                paid[resource] = max(0, cost[resource] - self.get_production().get(resource, 0))
                self.resources[resource] = max(0, self.resources.get(resource, 0) - (
                        cost[resource] - self.get_production().get(resource, 0)))
            return paid


#  1-25 resources 1,1,1
#  26-30 2 resources
#  31-45 reserve card
#  46-57 build card from trade row
#  58-60 build card from reserve
options = ((Resource.RED, Resource.GREEN, Resource.BLUE), (Resource.RED, Resource.GREEN, Resource.BROWN),
           (Resource.RED, Resource.GREEN, Resource.WHITE), (Resource.RED, Resource.BLUE, Resource.BROWN),
           (Resource.RED, Resource.BLUE, Resource.WHITE), (Resource.RED, Resource.BROWN, Resource.WHITE),
           (Resource.GREEN, Resource.BLUE, Resource.BROWN), (Resource.GREEN, Resource.BLUE, Resource.WHITE),
           (Resource.GREEN, Resource.BROWN, Resource.WHITE), (Resource.BLUE, Resource.BROWN, Resource.WHITE),

           (Resource.RED, Resource.GREEN), (Resource.RED, Resource.BLUE), (Resource.RED, Resource.BROWN),
           (Resource.RED, Resource.WHITE), (Resource.GREEN, Resource.BLUE), (Resource.GREEN, Resource.BROWN),
           (Resource.GREEN, Resource.WHITE), (Resource.BLUE, Resource.BROWN), (Resource.BLUE, Resource.WHITE),
           (Resource.BROWN, Resource.WHITE),

           (Resource.RED,), (Resource.GREEN,), (Resource.BLUE,), (Resource.BROWN,), (Resource.WHITE,),

           (Resource.RED, Resource.RED), (Resource.GREEN, Resource.GREEN),
           (Resource.BLUE, Resource.BLUE), (Resource.BROWN, Resource.BROWN), (Resource.WHITE, Resource.WHITE),

           (Tier.FIRST, 0), (Tier.SECOND, 0), (Tier.THIRD, 0), (Tier.FIRST, 1), (Tier.SECOND, 1), (Tier.THIRD, 1),
           (Tier.FIRST, 2), (Tier.SECOND, 2), (Tier.THIRD, 2), (Tier.FIRST, 3), (Tier.SECOND, 3), (Tier.THIRD, 3),
           (Tier.FIRST, 4), (Tier.SECOND, 4), (Tier.THIRD, 4),

           (Tier.FIRST, 0), (Tier.SECOND, 0), (Tier.THIRD, 0), (Tier.FIRST, 1), (Tier.SECOND, 1), (Tier.THIRD, 1),
           (Tier.FIRST, 2), (Tier.SECOND, 2), (Tier.THIRD, 2), (Tier.FIRST, 3), (Tier.SECOND, 3), (Tier.THIRD, 3),

           0, 1, 2
           )

res_trans = {1: Resource.RED, 2: Resource.GREEN, 3: Resource.BLUE, 4: Resource.BROWN, 5: Resource.WHITE,
             6: Resource.GOLD}


def is_possible(option_index, player_instance, game):
    if option_index in resource_111:
        if sum(player_instance.resources.values()) + len(options[option_index]) <= player_resource_max:
            for resource in options[option_index]:
                if game.available_resources.get(resource, 0) < 1:
                    break
            else:
                return True
    elif option_index in resource_2:
        if sum(player_instance.resources.values()) + len(options[option_index]) <= player_resource_max:
            for resource in options[option_index]:
                if game.available_resources[resource] < resource_limit_for_two:
                    break
            else:
                return True
    elif option_index in reserve_card:
        if options[option_index][1] == 4:
            if len(game.cards[options[option_index][0].value]) >= 1:
                if len(player_instance.reserve) < 3:
                    return True
        return game.visible_cards[options[option_index][1]] is not None
    elif option_index in build_card_row:
        card = game.visible_cards[options[option_index][1]]
        if is_purchase_possible(player_instance, card):
            return True
    elif option_index in build_card_reserve:
        index = options[option_index]
        if index < len(player_instance.reserve):
            card = player_instance.reserve[index]
            if is_purchase_possible(player_instance, card):
                return True
    return False


def is_purchase_possible(player_instance, card):
    if card is not None:
        copy = deepcopy(player_instance)
        try:
            copy.pay(card.cost)
            return True
        except ValueError:
            return False


def possible_option(combination, player_instance, game):
    wanted = combination.sort(reversed=True)
    for option in wanted:
        option_index = combination.index(option)
        if is_possible(option_index, player_instance, game):
            return option_index


options = ((Resource.RED, Resource.GREEN, Resource.BLUE), (Resource.RED, Resource.GREEN, Resource.BROWN),
           (Resource.RED, Resource.GREEN, Resource.WHITE), (Resource.RED, Resource.BLUE, Resource.BROWN),
           (Resource.RED, Resource.BLUE, Resource.WHITE), (Resource.RED, Resource.BROWN, Resource.WHITE),
           (Resource.GREEN, Resource.BLUE, Resource.BROWN), (Resource.GREEN, Resource.BLUE, Resource.WHITE),
           (Resource.GREEN, Resource.BROWN, Resource.WHITE), (Resource.BLUE, Resource.BROWN, Resource.WHITE),

           (Resource.RED, Resource.GREEN), (Resource.RED, Resource.BLUE), (Resource.RED, Resource.BROWN),
           (Resource.RED, Resource.WHITE), (Resource.GREEN, Resource.BLUE), (Resource.GREEN, Resource.BROWN),
           (Resource.GREEN, Resource.WHITE), (Resource.BLUE, Resource.BROWN), (Resource.BLUE, Resource.WHITE),
           (Resource.BROWN, Resource.WHITE),

           (Resource.RED,), (Resource.GREEN,), (Resource.BLUE,), (Resource.BROWN,), (Resource.WHITE,),

           (Resource.RED, Resource.RED), (Resource.GREEN, Resource.GREEN),
           (Resource.BLUE, Resource.BLUE), (Resource.BROWN, Resource.BROWN), (Resource.WHITE, Resource.WHITE),

           (Tier.FIRST, 0), (Tier.SECOND, 0), (Tier.THIRD, 0), (Tier.FIRST, 1), (Tier.SECOND, 1), (Tier.THIRD, 1),
           (Tier.FIRST, 2), (Tier.SECOND, 2), (Tier.THIRD, 2), (Tier.FIRST, 3), (Tier.SECOND, 3), (Tier.THIRD, 3),
           (Tier.FIRST, 4), (Tier.SECOND, 4), (Tier.THIRD, 4),

           (Tier.FIRST, 0), (Tier.SECOND, 0), (Tier.THIRD, 0), (Tier.FIRST, 1), (Tier.SECOND, 1), (Tier.THIRD, 1),
           (Tier.FIRST, 2), (Tier.SECOND, 2), (Tier.THIRD, 2), (Tier.FIRST, 3), (Tier.SECOND, 3), (Tier.THIRD, 3),

           0, 1, 2
           )


class Tester:
    def __init__(self, game):
        self.n_games = 0
        self.game = game
        self.current_player = self.game.players[0]

    def get_state(self):
        return self.game.get_state()

    def get_action(self, state=None):
        # random moves: tradeoff exploration / exploitation
        return self.current_player.get_action(self.game)

    def play_step(self, option_index):
        if option_index in resource_111 or option_index in resource_2:
            self.current_player.get_resource(options[option_index])
        elif option_index in reserve_card:
            tier, index = options[option_index]
            self.current_player.reserve.append(self.game.board.reserve_card(tier, index))
            if self.game.board.available_resources[Resource.GOLD] > 0 and sum(
                    self.current_player.resources.values()) < player_resource_max:
                self.current_player.get_resource((Resource.GOLD,))
        elif option_index in build_card_row:
            tier, index = options[option_index]
            card = self.game.board.take_card(tier, index)
            self.current_player.pay(card.cost)
            self.current_player.get_card(card)
        elif option_index in build_card_reserve:
            index = options[option_index]
            self.current_player.pay(self.current_player.reserve[index].cost)
            self.current_player.build_reserve(index)
        self.game.board.check_aristocrats(self.current_player)
        self.game.end_turn()
        end = self.current_player.points >= 15
        if not end: self.current_player = self.game.players[0]
        return end

    def _is_possible(self, option_index):
        if option_index in resource_111:
            if sum(self.current_player.resources.values()) + len(options[option_index]) <= player_resource_max:
                for resource in options[option_index]:
                    if self.game.board.available_resources.get(resource, 0) < 1:
                        break
                else:
                    return True
        elif option_index in resource_2:
            if sum(self.current_player.resources.values()) + len(options[option_index]) <= player_resource_max:
                for resource in options[option_index]:
                    if self.game.board.available_resources[resource] < resource_limit_for_two:
                        break
                else:
                    return True
        elif option_index in reserve_card:
            if options[option_index][1] == 4:
                if len(self.game.board.cards[options[option_index][0].value]) >= 1:
                    if len(self.current_player.reserve) < 3:
                        return True
            return self.game.board.visible_cards[options[option_index][1]] is not None and len(
                self.current_player.reserve) < 3
        elif option_index in build_card_row:
            tier, index = options[option_index]
            card = self.game.board.visible_cards[cards_in_row * tier.value + index]
            if self._is_purchase_possible(card):
                return True
        elif option_index in build_card_reserve:
            index = options[option_index]
            if index < len(self.current_player.reserve):
                card = self.current_player.reserve[index]
                if self._is_purchase_possible(card):
                    return True
        return False

    def _is_purchase_possible(self, card):
        if card is not None:
            copy = deepcopy(self.current_player.resources)
            try:
                self.current_player.pay(card.cost)
                self.current_player.resources = copy
                return True
            except ValueError:
                self.current_player.resources = copy
                return False

    def possible_option(self, combination):
        wanted = sorted(combination, reverse=True)
        for option in wanted:
            option_index = combination.index(option)
            if self._is_possible(option_index):
                return option_index

import matplotlib.pyplot as plt
from IPython import display
from statistics import mean

maximums = []
means = []
recent_max = []


def eval_genomes(genomes, config):
    global maximums, means, recent_max
    fitness = {}
    for i in range(2, len(genomes), 2):
        game = Game(genomes[i - 2:i], config)
        t = Tester(game)
        counter = 0
        while t.game.round <= 10:
            action = t.get_action()
            option = t.possible_option(action)
            if option is None:
                t.game.end_turn()
                counter += 1
                if counter >= 3:
                    # for player in t.game.players:
                    #     fitness[player.id] = fitness.get(player.id, 0) + player.points
                    t.game.reset()
                continue
            else:
                counter = 0
            if t.play_step(option):
                for player in t.game.players:
                    fitness[player.id] = fitness.get(player.id, 0) + player.points
                fitness[t.current_player.id] = fitness.get(t.current_player.id, 0) + 15
                t.game.reset()
    results = []
    for genome_id, genome in genomes:
        genome.fitness = fitness.get(genome_id, 0)
        results.append(fitness.get(genome_id, 0))
    average = mean(results)
    maximum = max(results)
    maximums.append(maximum)
    means.append(average)
    recent_max.append(mean(maximums[-min(30, len(maximums)):]))
    display.clear_output(wait=True)
    display.display(plt.gcf())
    plt.clf()
    plt.title('Training...')
    plt.xlabel('Number of Games')
    plt.ylabel('Score')
    plt.plot(maximums)
    plt.plot(means)
    plt.plot(recent_max)
    plt.plot()
    plt.ylim(ymin=0)
    plt.text(len(maximums)-1, maximums[-1], str(maximums[-1]))
    plt.text(len(means)-1, means[-1], str(means[-1]))
    plt.show(block=False)
    plt.pause(.1)


def run(config_file):
    config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,
                                neat.DefaultSpeciesSet, neat.DefaultStagnation,
                                config_file)
    # p = neat.Checkpointer.restore_checkpoint('neat-checkpoint-222')

    # Create the population, which is the top-level object for a NEAT run.
    p = neat.Population(config)

    # Add a stdout reporter to show progress in the terminal.
    p.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    p.add_reporter(stats)
    p.add_reporter(neat.Checkpointer(10))

    # Run for up to 50 generations.
    winner = p.run(eval_genomes, 100000)

    # show final stats
    print('\nBest genome:\n{!s}'.format(winner))


run("that_is_the_neat_part/configuration.txt")
